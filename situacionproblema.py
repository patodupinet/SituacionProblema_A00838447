# -*- coding: utf-8 -*-
"""SituacionProblema.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QcWAlof7-qcHMaxx50w6igHmV09bGW6g
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.stattools import adfuller, coint, acf, pacf
from statsmodels.tsa.ar_model import AutoReg
from statsmodels.tsa.arima.model import ARIMA
import warnings
import os
warnings.filterwarnings('ignore')
from google.colab import files

# Function to upload and read Excel files one by one with retry option
def upload_and_read_files():
    data = {}
    expected_files = ['ibm_1min.xlsx', 'ibm_5min.xlsx', 'schw_1min.xlsx', 'schw_5min.xlsx',
                     'abbv_1min.xlsx', 'abbv_5min.xlsx', 'mdlz_1min.xlsx', 'mdlz_5min.xlsx']

    # Clear existing files in Colab's working directory to avoid naming conflicts
    for file in os.listdir():
        if file.endswith('.xlsx'):
            os.remove(file)

    for file_name in expected_files:
        while True:
            print(f"Please upload {file_name}")
            uploaded = files.upload()
            # Check for uploaded file, accounting for potential renaming by Colab
            uploaded_file = None
            for uploaded_name in uploaded.keys():
                if uploaded_name.startswith(file_name.replace('.xlsx', '')):
                    uploaded_file = uploaded_name
                    break
            if uploaded_file:
                key = file_name.replace('.xlsx', '')
                try:
                    data[key] = pd.read_excel(uploaded_file)['Close']
                    print(f"Successfully loaded {file_name}")
                    # Remove the uploaded file to prevent conflicts in next run
                    os.remove(uploaded_file)
                    break
                except KeyError:
                    print(f"Error: 'Close' column not found in {file_name}. Please check the file and try again.")
                    retry = input("Would you like to retry uploading this file? (yes/no): ").lower()
                    if retry != 'yes':
                        print(f"Skipping {file_name}.")
                        break
                    os.remove(uploaded_file)
                except Exception as e:
                    print(f"Error loading {file_name}: {str(e)}. Please try again.")
                    retry = input("Would you like to retry uploading this file? (yes/no): ").lower()
                    if retry != 'yes':
                        print(f"Skipping {file_name}.")
                        break
                    os.remove(uploaded_file)
            else:
                print(f"Error: {file_name} not uploaded or incorrect file name.")
                retry = input("Would you like to retry uploading this file? (yes/no): ").lower()
                if retry != 'yes':
                    print(f"Skipping {file_name}.")
                    break
    return data

# Function to perform ADF test and differentiate if non-stationary
def adf_test_and_differentiate(series, name):
    print(f"\nADF Test for {name}:")
    result = adfuller(series.dropna())
    adf_stat = result[0]
    p_value = result[1]
    critical_values = result[4]
    print(f'ADF Statistic: {adf_stat:.4f}')
    print(f'p-value: {p_value:.4f}')
    print(f'Critical Values: 1%={critical_values["1%"]:.4f}, 5%={critical_values["5%"]:.4f}, 10%={critical_values["10%"]:.4f})')
    if p_value <= 0.05:
        print(f"{name} is stationary (p-value <= 0.05).")
        print("Interpretation: The series has no unit root, indicating constant mean, variance, and autocovariance over time. It is suitable for time series modeling without differencing.")
        return series, 0
    else:
        print(f"{name} is non-stationary (p-value > 0.05).")
        print("Interpretation: The series has a unit root, suggesting trends or non-constant mean/variance. Differencing is required to achieve stationarity.")
        diff_count = 0
        temp_series = series.copy()
        while p_value > 0.05 and diff_count < 3:
            diff_count += 1
            temp_series = temp_series.diff().dropna()
            result = adfuller(temp_series)
            adf_stat = result[0]
            p_value = result[1]
            critical_values = result[4]
            print(f"\nAfter {diff_count} differentiation(s):")
            print(f'ADF Statistic: {adf_stat:.4f}')
            print(f'p-value: {p_value:.4f}')
            print(f'Critical Values: 1%={critical_values["1%"]:.4f}, 5%={critical_values["5%"]:.4f}, 10%={critical_values["10%"]:.4f})')
            if p_value <= 0.05:
                print(f"{name} is stationary after {diff_count} differentiation(s).")
                print(f"Interpretation: After {diff_count} differencing, the series has no unit root, making it stationary and suitable for modeling.")
            else:
                print(f"{name} remains non-stationary after {diff_count} differentiation(s).")
                print(f"Interpretation: The series still exhibits non-stationarity, indicating persistent trends or volatility.")
        if p_value > 0.05:
            print(f"Warning: {name} remains non-stationary after {diff_count} differentiations. Proceeding with {diff_count} differences.")
        return temp_series, diff_count

# Function to perform cointegration test between two series
def cointegration_test(series1, series2, name1, name2, diff_count1, diff_count2):
    print(f"\nCointegration Test between {name1} and {name2}:")
    # Skip cointegration test if both series are stationary
    if diff_count1 == 0 and diff_count2 == 0:
        print("Both series are stationary (I(0)). Cointegration test is not applicable.")
        print("Interpretation: Since both series are stationary, they do not require a long-term equilibrium relationship to be tested for cointegration.")
        return
    # Align series to the same length
    min_length = min(len(series1), len(series2))
    series1 = series1.dropna()[:min_length]
    series2 = series2.dropna()[:min_length]
    try:
        score, p_value, critical_values = coint(series1, series2)
        print(f'Cointegration t-statistic: {score:.4f}')
        print(f'p-value: {p_value:.4f}')
        print(f'Critical Values: 1%={critical_values[0]:.4f}, 5%={critical_values[1]:.4f}, 10%={critical_values[2]:.4f}')
        if p_value < 0.05:
            print(f"Evidence of cointegration between {name1} and {name2} (p-value < 0.05).")
            print("Interpretation: The series share a stable long-term relationship, meaning their linear combination is stationary despite individual non-stationarity. This suggests potential for pairs trading or mean-reverting strategies.")
        else:
            print(f"No evidence of cointegration between {name1} and {name2} (p-value >= 0.05).")
            print("Interpretation: The series do not share a stable long-term relationship, indicating independent long-term movements. Cointegration-based strategies are not applicable.")
    except Exception as e:
        print(f"Error in cointegration test: {str(e)}. Skipping this test.")

# Function to plot price with moving average
def plot_price_with_ma(series, name):
    ma = series.rolling(window=20).mean()
    plt.figure(figsize=(10, 5))
    plt.plot(series.index, series, label='Price')
    plt.plot(series.index, ma, label='20-Period MA', linestyle='--')
    plt.title(f'{name} Price with Moving Average')
    plt.xlabel('Observation Number')
    plt.ylabel('Price')
    plt.legend()
    plt.grid()
    plt.show()

# Function to plot ACF and PACF with interpretation
def plot_acf_pacf(series, name, lags=36):
    plt.figure(figsize=(12, 6))
    plt.subplot(1, 2, 1)
    acf_vals = acf(series.dropna(), nlags=lags, fft=True)
    plt.stem(range(len(acf_vals)), acf_vals)
    plt.title(f'ACF - {name}')
    plt.xlabel('Lag')
    plt.ylabel('Autocorrelation')
    plt.subplot(1, 2, 2)
    pacf_vals = pacf(series.dropna(), nlags=lags)
    plt.stem(range(len(pacf_vals)), pacf_vals)
    plt.title(f'PACF - {name}')
    plt.xlabel('Lag')
    plt.ylabel('Partial Autocorrelation')
    plt.tight_layout()
    plt.show()

    # ACF Interpretation
    print(f"\nACF Interpretation for {name}:")
    significant_lags = [lag for lag in range(1, lags+1) if abs(acf_vals[lag]) > 1.96/np.sqrt(len(series))]
    if not significant_lags:
        print("No significant autocorrelation beyond lag 0, suggesting a white noise process or weak serial correlation.")
    elif len(significant_lags) <= 3:
        print(f"Significant autocorrelation at lags {significant_lags}. This suggests a short-memory process, possibly requiring a low-order MA model.")
    else:
        print(f"Significant autocorrelation at lags {significant_lags[:5]}{'...' if len(significant_lags) > 5 else ''}. This indicates a longer-memory process, possibly requiring an AR or ARMA model.")

    # PACF Interpretation
    print(f"\nPACF Interpretation for {name}:")
    significant_pacf_lags = [lag for lag in range(1, lags+1) if abs(pacf_vals[lag]) > 1.96/np.sqrt(len(series))]
    if not significant_pacf_lags:
        print("No significant partial autocorrelation, suggesting minimal direct lag effects after removing earlier lags.")
    elif len(significant_pacf_lags) == 1:
        print(f"Significant partial autocorrelation at lag {significant_pacf_lags[0]}. This suggests an AR(1) model may be appropriate.")
    elif len(significant_pacf_lags) <= 3:
        print(f"Significant partial autocorrelation at lags {significant_pacf_lags}. This suggests a low-order AR model (e.g., AR({max(significant_pacf_lags)})).")
    else:
        print(f"Significant partial autocorrelation at lags {significant_pacf_lags[:5]}{'...' if len(significant_pacf_lags) > 5 else ''}. This indicates a complex AR process, potentially requiring a higher-order AR or ARIMA model.")

# Function to fit AR, ARMA, ARIMA models and forecast
def fit_and_forecast(series, name, diff_count):
    print(f"\nModeling for {name}:")
    series = series.dropna()
    # AR Model
    ar_model = AutoReg(series, lags=1).fit()
    ar_forecast = ar_model.forecast(steps=10)
    print("\nAR(1) Model Summary:")
    print(ar_model.summary())

    # ARMA Model (assuming ARMA(1,1))
    arma_model = ARIMA(series, order=(1, 0, 1)).fit()
    arma_forecast = arma_model.forecast(steps=10)
    print("\nARMA(1,1) Model Summary:")
    print(arma_model.summary())

    # ARIMA Model (using diff_count for integration order)
    arima_model = ARIMA(series, order=(1, diff_count, 1)).fit()
    arima_forecast = arima_model.forecast(steps=10)
    print("\nARIMA(1,{},1) Model Summary:".format(diff_count))
    print(arima_model.summary())

    # Display AR and ARMA forecast values
    print(f"\nAR Forecasted Values for {name} (Next 10 Observations):")
    for i, val in enumerate(ar_forecast, 1):
        print(f"Observation {i}: {val:.4f}")

    print(f"\nARMA Forecasted Values for {name} (Next 10 Observations):")
    for i, val in enumerate(arma_forecast, 1):
        print(f"Observation {i}: {val:.4f}")

    # Calculate percentage changes for AR and ARMA forecasts
    last_price = series.iloc[-1]
    ar_last_forecast = ar_forecast.iloc[-1]
    arma_last_forecast = arma_forecast.iloc[-1]
    ar_perc_change = ((ar_last_forecast - last_price) / last_price) * 100
    arma_perc_change = ((arma_last_forecast - last_price) / last_price) * 100
    print(f"\nAR Forecasted percentage change for {name}: {ar_perc_change:.2f}%")
    print(f"ARMA Forecasted percentage change for {name}: {arma_perc_change:.2f}%")

    # Buy/Sell/Hold Decision based on average of AR and ARMA percentage changes
    avg_perc_change = (ar_perc_change + arma_perc_change) / 2
    print(f"Average forecasted percentage change (AR and ARMA) for {name}: {avg_perc_change:.2f}%")
    if avg_perc_change > 0.1:
        decision = "Buy"
        print(f"Decision: {decision} - Average expected price increase > 0.1%.")
    elif avg_perc_change < -0.1:
        decision = "Sell"
        print(f"Decision: {decision} - Average expected price decrease > 0.1%.")
    else:
        decision = "Hold"
        print(f"Decision: {decision} - Average expected price change within ±0.1%.")

    # Plot forecasts
    plt.figure(figsize=(10, 5))
    plt.plot(series.index[-50:], series[-50:], label='Actual')
    forecast_index = np.arange(len(series), len(series) + 10)
    plt.plot(forecast_index, ar_forecast, label='AR Forecast', linestyle='--')
    plt.plot(forecast_index, arma_forecast, label='ARMA Forecast', linestyle='-.')
    plt.plot(forecast_index, arima_forecast, label='ARIMA Forecast', linestyle=':')
    plt.title(f'{name} Price Forecast')
    plt.xlabel('Observation Number')
    plt.ylabel('Price')
    plt.legend()
    plt.grid()
    plt.show()

    return ar_forecast, arma_forecast, arima_forecast, decision

# Main execution
data = upload_and_read_files()
results = {}
diff_counts = {}

for name, series in data.items():
    print(f"\n\n=== Analysis for {name} ===")
    series.index = range(len(series))  # Set index to observation numbers

    # Plot price with moving average
    plot_price_with_ma(series, name)

    # ADF test and differentiation
    stationary_series, diff_count = adf_test_and_differentiate(series, name)
    diff_counts[name] = diff_count

    # ACF and PACF plots
    plot_acf_pacf(stationary_series, name)

    # Fit models and forecast
    ar_forecast, arma_forecast, arima_forecast, decision = fit_and_forecast(series, name, diff_count)

    results[name] = {
        'stationary_series': stationary_series,
        'diff_count': diff_count,
        'ar_forecast': ar_forecast,
        'arma_forecast': arma_forecast,
        'arima_forecast': arima_forecast,
        'decision': decision
    }

# Cointegration tests between 1-min and 5-min series for each stock
stocks = ['ibm', 'schw', 'abbv', 'mdlz']
for stock in stocks:
    series1 = data.get(f'{stock}_1min')
    series2 = data.get(f'{stock}_5min')
    if series1 is not None and series2 is not None:
        diff_count1 = diff_counts.get(f'{stock}_1min', 0)
        diff_count2 = diff_counts.get(f'{stock}_5min', 0)
        cointegration_test(series1, series2, f'{stock}_1min', f'{stock}_5min', diff_count1, diff_count2)

# Summary of decisions
print("\n\n=== Summary of Trading Decisions ===")
for name, res in results.items():
    print(f"{name}: {res['decision']}")